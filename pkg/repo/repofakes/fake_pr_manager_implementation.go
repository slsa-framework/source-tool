// Code generated by counterfeiter. DO NOT EDIT.
package repofakes

import (
	"sync"

	"github.com/slsa-framework/source-tool/pkg/auth"
	"github.com/slsa-framework/source-tool/pkg/repo"
	"github.com/slsa-framework/source-tool/pkg/repo/options"
	"github.com/slsa-framework/source-tool/pkg/sourcetool/models"
)

type FakePrManagerImplementation struct {
	CheckForkStub        func(*options.PullRequestManagerOptions, *auth.Authenticator, *models.Repository, string) (*models.Repository, error)
	checkForkMutex       sync.RWMutex
	checkForkArgsForCall []struct {
		arg1 *options.PullRequestManagerOptions
		arg2 *auth.Authenticator
		arg3 *models.Repository
		arg4 string
	}
	checkForkReturns struct {
		result1 *models.Repository
		result2 error
	}
	checkForkReturnsOnCall map[int]struct {
		result1 *models.Repository
		result2 error
	}
	CloneRepoStub        func(*options.PullRequestManagerOptions, *auth.Authenticator, *models.Repository) (*repo.Clone, error)
	cloneRepoMutex       sync.RWMutex
	cloneRepoArgsForCall []struct {
		arg1 *options.PullRequestManagerOptions
		arg2 *auth.Authenticator
		arg3 *models.Repository
	}
	cloneRepoReturns struct {
		result1 *repo.Clone
		result2 error
	}
	cloneRepoReturnsOnCall map[int]struct {
		result1 *repo.Clone
		result2 error
	}
	CommitChangesStub        func(*options.PullRequestFileListOptions, *repo.Clone) error
	commitChangesMutex       sync.RWMutex
	commitChangesArgsForCall []struct {
		arg1 *options.PullRequestFileListOptions
		arg2 *repo.Clone
	}
	commitChangesReturns struct {
		result1 error
	}
	commitChangesReturnsOnCall map[int]struct {
		result1 error
	}
	CopyFilesToCloneStub        func(*repo.Clone, []*repo.PullRequestFileEntry) error
	copyFilesToCloneMutex       sync.RWMutex
	copyFilesToCloneArgsForCall []struct {
		arg1 *repo.Clone
		arg2 []*repo.PullRequestFileEntry
	}
	copyFilesToCloneReturns struct {
		result1 error
	}
	copyFilesToCloneReturnsOnCall map[int]struct {
		result1 error
	}
	CreatePullRequestStub        func(*options.PullRequestManagerOptions, *auth.Authenticator, *models.Repository, *options.PullRequestOptions) (*models.PullRequest, error)
	createPullRequestMutex       sync.RWMutex
	createPullRequestArgsForCall []struct {
		arg1 *options.PullRequestManagerOptions
		arg2 *auth.Authenticator
		arg3 *models.Repository
		arg4 *options.PullRequestOptions
	}
	createPullRequestReturns struct {
		result1 *models.PullRequest
		result2 error
	}
	createPullRequestReturnsOnCall map[int]struct {
		result1 *models.PullRequest
		result2 error
	}
	PushFeatureBranchStub        func(*options.PullRequestManagerOptions, *repo.Clone) error
	pushFeatureBranchMutex       sync.RWMutex
	pushFeatureBranchArgsForCall []struct {
		arg1 *options.PullRequestManagerOptions
		arg2 *repo.Clone
	}
	pushFeatureBranchReturns struct {
		result1 error
	}
	pushFeatureBranchReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePrManagerImplementation) CheckFork(arg1 *options.PullRequestManagerOptions, arg2 *auth.Authenticator, arg3 *models.Repository, arg4 string) (*models.Repository, error) {
	fake.checkForkMutex.Lock()
	ret, specificReturn := fake.checkForkReturnsOnCall[len(fake.checkForkArgsForCall)]
	fake.checkForkArgsForCall = append(fake.checkForkArgsForCall, struct {
		arg1 *options.PullRequestManagerOptions
		arg2 *auth.Authenticator
		arg3 *models.Repository
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.CheckForkStub
	fakeReturns := fake.checkForkReturns
	fake.recordInvocation("CheckFork", []interface{}{arg1, arg2, arg3, arg4})
	fake.checkForkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePrManagerImplementation) CheckForkCallCount() int {
	fake.checkForkMutex.RLock()
	defer fake.checkForkMutex.RUnlock()
	return len(fake.checkForkArgsForCall)
}

func (fake *FakePrManagerImplementation) CheckForkCalls(stub func(*options.PullRequestManagerOptions, *auth.Authenticator, *models.Repository, string) (*models.Repository, error)) {
	fake.checkForkMutex.Lock()
	defer fake.checkForkMutex.Unlock()
	fake.CheckForkStub = stub
}

func (fake *FakePrManagerImplementation) CheckForkArgsForCall(i int) (*options.PullRequestManagerOptions, *auth.Authenticator, *models.Repository, string) {
	fake.checkForkMutex.RLock()
	defer fake.checkForkMutex.RUnlock()
	argsForCall := fake.checkForkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakePrManagerImplementation) CheckForkReturns(result1 *models.Repository, result2 error) {
	fake.checkForkMutex.Lock()
	defer fake.checkForkMutex.Unlock()
	fake.CheckForkStub = nil
	fake.checkForkReturns = struct {
		result1 *models.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakePrManagerImplementation) CheckForkReturnsOnCall(i int, result1 *models.Repository, result2 error) {
	fake.checkForkMutex.Lock()
	defer fake.checkForkMutex.Unlock()
	fake.CheckForkStub = nil
	if fake.checkForkReturnsOnCall == nil {
		fake.checkForkReturnsOnCall = make(map[int]struct {
			result1 *models.Repository
			result2 error
		})
	}
	fake.checkForkReturnsOnCall[i] = struct {
		result1 *models.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakePrManagerImplementation) CloneRepo(arg1 *options.PullRequestManagerOptions, arg2 *auth.Authenticator, arg3 *models.Repository) (*repo.Clone, error) {
	fake.cloneRepoMutex.Lock()
	ret, specificReturn := fake.cloneRepoReturnsOnCall[len(fake.cloneRepoArgsForCall)]
	fake.cloneRepoArgsForCall = append(fake.cloneRepoArgsForCall, struct {
		arg1 *options.PullRequestManagerOptions
		arg2 *auth.Authenticator
		arg3 *models.Repository
	}{arg1, arg2, arg3})
	stub := fake.CloneRepoStub
	fakeReturns := fake.cloneRepoReturns
	fake.recordInvocation("CloneRepo", []interface{}{arg1, arg2, arg3})
	fake.cloneRepoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePrManagerImplementation) CloneRepoCallCount() int {
	fake.cloneRepoMutex.RLock()
	defer fake.cloneRepoMutex.RUnlock()
	return len(fake.cloneRepoArgsForCall)
}

func (fake *FakePrManagerImplementation) CloneRepoCalls(stub func(*options.PullRequestManagerOptions, *auth.Authenticator, *models.Repository) (*repo.Clone, error)) {
	fake.cloneRepoMutex.Lock()
	defer fake.cloneRepoMutex.Unlock()
	fake.CloneRepoStub = stub
}

func (fake *FakePrManagerImplementation) CloneRepoArgsForCall(i int) (*options.PullRequestManagerOptions, *auth.Authenticator, *models.Repository) {
	fake.cloneRepoMutex.RLock()
	defer fake.cloneRepoMutex.RUnlock()
	argsForCall := fake.cloneRepoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePrManagerImplementation) CloneRepoReturns(result1 *repo.Clone, result2 error) {
	fake.cloneRepoMutex.Lock()
	defer fake.cloneRepoMutex.Unlock()
	fake.CloneRepoStub = nil
	fake.cloneRepoReturns = struct {
		result1 *repo.Clone
		result2 error
	}{result1, result2}
}

func (fake *FakePrManagerImplementation) CloneRepoReturnsOnCall(i int, result1 *repo.Clone, result2 error) {
	fake.cloneRepoMutex.Lock()
	defer fake.cloneRepoMutex.Unlock()
	fake.CloneRepoStub = nil
	if fake.cloneRepoReturnsOnCall == nil {
		fake.cloneRepoReturnsOnCall = make(map[int]struct {
			result1 *repo.Clone
			result2 error
		})
	}
	fake.cloneRepoReturnsOnCall[i] = struct {
		result1 *repo.Clone
		result2 error
	}{result1, result2}
}

func (fake *FakePrManagerImplementation) CommitChanges(arg1 *options.PullRequestFileListOptions, arg2 *repo.Clone) error {
	fake.commitChangesMutex.Lock()
	ret, specificReturn := fake.commitChangesReturnsOnCall[len(fake.commitChangesArgsForCall)]
	fake.commitChangesArgsForCall = append(fake.commitChangesArgsForCall, struct {
		arg1 *options.PullRequestFileListOptions
		arg2 *repo.Clone
	}{arg1, arg2})
	stub := fake.CommitChangesStub
	fakeReturns := fake.commitChangesReturns
	fake.recordInvocation("CommitChanges", []interface{}{arg1, arg2})
	fake.commitChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePrManagerImplementation) CommitChangesCallCount() int {
	fake.commitChangesMutex.RLock()
	defer fake.commitChangesMutex.RUnlock()
	return len(fake.commitChangesArgsForCall)
}

func (fake *FakePrManagerImplementation) CommitChangesCalls(stub func(*options.PullRequestFileListOptions, *repo.Clone) error) {
	fake.commitChangesMutex.Lock()
	defer fake.commitChangesMutex.Unlock()
	fake.CommitChangesStub = stub
}

func (fake *FakePrManagerImplementation) CommitChangesArgsForCall(i int) (*options.PullRequestFileListOptions, *repo.Clone) {
	fake.commitChangesMutex.RLock()
	defer fake.commitChangesMutex.RUnlock()
	argsForCall := fake.commitChangesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePrManagerImplementation) CommitChangesReturns(result1 error) {
	fake.commitChangesMutex.Lock()
	defer fake.commitChangesMutex.Unlock()
	fake.CommitChangesStub = nil
	fake.commitChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePrManagerImplementation) CommitChangesReturnsOnCall(i int, result1 error) {
	fake.commitChangesMutex.Lock()
	defer fake.commitChangesMutex.Unlock()
	fake.CommitChangesStub = nil
	if fake.commitChangesReturnsOnCall == nil {
		fake.commitChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.commitChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePrManagerImplementation) CopyFilesToClone(arg1 *repo.Clone, arg2 []*repo.PullRequestFileEntry) error {
	var arg2Copy []*repo.PullRequestFileEntry
	if arg2 != nil {
		arg2Copy = make([]*repo.PullRequestFileEntry, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.copyFilesToCloneMutex.Lock()
	ret, specificReturn := fake.copyFilesToCloneReturnsOnCall[len(fake.copyFilesToCloneArgsForCall)]
	fake.copyFilesToCloneArgsForCall = append(fake.copyFilesToCloneArgsForCall, struct {
		arg1 *repo.Clone
		arg2 []*repo.PullRequestFileEntry
	}{arg1, arg2Copy})
	stub := fake.CopyFilesToCloneStub
	fakeReturns := fake.copyFilesToCloneReturns
	fake.recordInvocation("CopyFilesToClone", []interface{}{arg1, arg2Copy})
	fake.copyFilesToCloneMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePrManagerImplementation) CopyFilesToCloneCallCount() int {
	fake.copyFilesToCloneMutex.RLock()
	defer fake.copyFilesToCloneMutex.RUnlock()
	return len(fake.copyFilesToCloneArgsForCall)
}

func (fake *FakePrManagerImplementation) CopyFilesToCloneCalls(stub func(*repo.Clone, []*repo.PullRequestFileEntry) error) {
	fake.copyFilesToCloneMutex.Lock()
	defer fake.copyFilesToCloneMutex.Unlock()
	fake.CopyFilesToCloneStub = stub
}

func (fake *FakePrManagerImplementation) CopyFilesToCloneArgsForCall(i int) (*repo.Clone, []*repo.PullRequestFileEntry) {
	fake.copyFilesToCloneMutex.RLock()
	defer fake.copyFilesToCloneMutex.RUnlock()
	argsForCall := fake.copyFilesToCloneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePrManagerImplementation) CopyFilesToCloneReturns(result1 error) {
	fake.copyFilesToCloneMutex.Lock()
	defer fake.copyFilesToCloneMutex.Unlock()
	fake.CopyFilesToCloneStub = nil
	fake.copyFilesToCloneReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePrManagerImplementation) CopyFilesToCloneReturnsOnCall(i int, result1 error) {
	fake.copyFilesToCloneMutex.Lock()
	defer fake.copyFilesToCloneMutex.Unlock()
	fake.CopyFilesToCloneStub = nil
	if fake.copyFilesToCloneReturnsOnCall == nil {
		fake.copyFilesToCloneReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copyFilesToCloneReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePrManagerImplementation) CreatePullRequest(arg1 *options.PullRequestManagerOptions, arg2 *auth.Authenticator, arg3 *models.Repository, arg4 *options.PullRequestOptions) (*models.PullRequest, error) {
	fake.createPullRequestMutex.Lock()
	ret, specificReturn := fake.createPullRequestReturnsOnCall[len(fake.createPullRequestArgsForCall)]
	fake.createPullRequestArgsForCall = append(fake.createPullRequestArgsForCall, struct {
		arg1 *options.PullRequestManagerOptions
		arg2 *auth.Authenticator
		arg3 *models.Repository
		arg4 *options.PullRequestOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreatePullRequestStub
	fakeReturns := fake.createPullRequestReturns
	fake.recordInvocation("CreatePullRequest", []interface{}{arg1, arg2, arg3, arg4})
	fake.createPullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePrManagerImplementation) CreatePullRequestCallCount() int {
	fake.createPullRequestMutex.RLock()
	defer fake.createPullRequestMutex.RUnlock()
	return len(fake.createPullRequestArgsForCall)
}

func (fake *FakePrManagerImplementation) CreatePullRequestCalls(stub func(*options.PullRequestManagerOptions, *auth.Authenticator, *models.Repository, *options.PullRequestOptions) (*models.PullRequest, error)) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = stub
}

func (fake *FakePrManagerImplementation) CreatePullRequestArgsForCall(i int) (*options.PullRequestManagerOptions, *auth.Authenticator, *models.Repository, *options.PullRequestOptions) {
	fake.createPullRequestMutex.RLock()
	defer fake.createPullRequestMutex.RUnlock()
	argsForCall := fake.createPullRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakePrManagerImplementation) CreatePullRequestReturns(result1 *models.PullRequest, result2 error) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = nil
	fake.createPullRequestReturns = struct {
		result1 *models.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakePrManagerImplementation) CreatePullRequestReturnsOnCall(i int, result1 *models.PullRequest, result2 error) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = nil
	if fake.createPullRequestReturnsOnCall == nil {
		fake.createPullRequestReturnsOnCall = make(map[int]struct {
			result1 *models.PullRequest
			result2 error
		})
	}
	fake.createPullRequestReturnsOnCall[i] = struct {
		result1 *models.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakePrManagerImplementation) PushFeatureBranch(arg1 *options.PullRequestManagerOptions, arg2 *repo.Clone) error {
	fake.pushFeatureBranchMutex.Lock()
	ret, specificReturn := fake.pushFeatureBranchReturnsOnCall[len(fake.pushFeatureBranchArgsForCall)]
	fake.pushFeatureBranchArgsForCall = append(fake.pushFeatureBranchArgsForCall, struct {
		arg1 *options.PullRequestManagerOptions
		arg2 *repo.Clone
	}{arg1, arg2})
	stub := fake.PushFeatureBranchStub
	fakeReturns := fake.pushFeatureBranchReturns
	fake.recordInvocation("PushFeatureBranch", []interface{}{arg1, arg2})
	fake.pushFeatureBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePrManagerImplementation) PushFeatureBranchCallCount() int {
	fake.pushFeatureBranchMutex.RLock()
	defer fake.pushFeatureBranchMutex.RUnlock()
	return len(fake.pushFeatureBranchArgsForCall)
}

func (fake *FakePrManagerImplementation) PushFeatureBranchCalls(stub func(*options.PullRequestManagerOptions, *repo.Clone) error) {
	fake.pushFeatureBranchMutex.Lock()
	defer fake.pushFeatureBranchMutex.Unlock()
	fake.PushFeatureBranchStub = stub
}

func (fake *FakePrManagerImplementation) PushFeatureBranchArgsForCall(i int) (*options.PullRequestManagerOptions, *repo.Clone) {
	fake.pushFeatureBranchMutex.RLock()
	defer fake.pushFeatureBranchMutex.RUnlock()
	argsForCall := fake.pushFeatureBranchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePrManagerImplementation) PushFeatureBranchReturns(result1 error) {
	fake.pushFeatureBranchMutex.Lock()
	defer fake.pushFeatureBranchMutex.Unlock()
	fake.PushFeatureBranchStub = nil
	fake.pushFeatureBranchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePrManagerImplementation) PushFeatureBranchReturnsOnCall(i int, result1 error) {
	fake.pushFeatureBranchMutex.Lock()
	defer fake.pushFeatureBranchMutex.Unlock()
	fake.PushFeatureBranchStub = nil
	if fake.pushFeatureBranchReturnsOnCall == nil {
		fake.pushFeatureBranchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pushFeatureBranchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePrManagerImplementation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePrManagerImplementation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
