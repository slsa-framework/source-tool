// Code generated by counterfeiter. DO NOT EDIT.
package sourcetoolfakes

import (
	"context"
	"sync"

	"github.com/slsa-framework/slsa-source-poc/sourcetool/pkg/auth"
	"github.com/slsa-framework/slsa-source-poc/sourcetool/pkg/policy"
	"github.com/slsa-framework/slsa-source-poc/sourcetool/pkg/slsa"
	"github.com/slsa-framework/slsa-source-poc/sourcetool/pkg/sourcetool/models"
	"github.com/slsa-framework/slsa-source-poc/sourcetool/pkg/sourcetool/options"
)

type FakeToolImplementation struct {
	CheckForksStub        func(*options.Options) error
	checkForksMutex       sync.RWMutex
	checkForksArgsForCall []struct {
		arg1 *options.Options
	}
	checkForksReturns struct {
		result1 error
	}
	checkForksReturnsOnCall map[int]struct {
		result1 error
	}
	CheckPolicyForkStub        func(*options.Options) error
	checkPolicyForkMutex       sync.RWMutex
	checkPolicyForkArgsForCall []struct {
		arg1 *options.Options
	}
	checkPolicyForkReturns struct {
		result1 error
	}
	checkPolicyForkReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigureControlsStub        func(models.VcsBackend, *models.Repository, []*models.Branch, []models.ControlConfiguration) error
	configureControlsMutex       sync.RWMutex
	configureControlsArgsForCall []struct {
		arg1 models.VcsBackend
		arg2 *models.Repository
		arg3 []*models.Branch
		arg4 []models.ControlConfiguration
	}
	configureControlsReturns struct {
		result1 error
	}
	configureControlsReturnsOnCall map[int]struct {
		result1 error
	}
	CreatePolicyPRStub        func(*auth.Authenticator, *options.Options, *models.Repository, *policy.RepoPolicy) (*models.PullRequest, error)
	createPolicyPRMutex       sync.RWMutex
	createPolicyPRArgsForCall []struct {
		arg1 *auth.Authenticator
		arg2 *options.Options
		arg3 *models.Repository
		arg4 *policy.RepoPolicy
	}
	createPolicyPRReturns struct {
		result1 *models.PullRequest
		result2 error
	}
	createPolicyPRReturnsOnCall map[int]struct {
		result1 *models.PullRequest
		result2 error
	}
	GetAttestationReaderStub        func(*models.Repository) (models.AttestationStorageReader, error)
	getAttestationReaderMutex       sync.RWMutex
	getAttestationReaderArgsForCall []struct {
		arg1 *models.Repository
	}
	getAttestationReaderReturns struct {
		result1 models.AttestationStorageReader
		result2 error
	}
	getAttestationReaderReturnsOnCall map[int]struct {
		result1 models.AttestationStorageReader
		result2 error
	}
	GetBranchControlsStub        func(context.Context, models.VcsBackend, *models.Repository, *models.Branch) (*slsa.ControlSetStatus, error)
	getBranchControlsMutex       sync.RWMutex
	getBranchControlsArgsForCall []struct {
		arg1 context.Context
		arg2 models.VcsBackend
		arg3 *models.Repository
		arg4 *models.Branch
	}
	getBranchControlsReturns struct {
		result1 *slsa.ControlSetStatus
		result2 error
	}
	getBranchControlsReturnsOnCall map[int]struct {
		result1 *slsa.ControlSetStatus
		result2 error
	}
	GetPolicyStatusStub        func(context.Context, *auth.Authenticator, *options.Options, *models.Repository) (*slsa.ControlStatus, error)
	getPolicyStatusMutex       sync.RWMutex
	getPolicyStatusArgsForCall []struct {
		arg1 context.Context
		arg2 *auth.Authenticator
		arg3 *options.Options
		arg4 *models.Repository
	}
	getPolicyStatusReturns struct {
		result1 *slsa.ControlStatus
		result2 error
	}
	getPolicyStatusReturnsOnCall map[int]struct {
		result1 *slsa.ControlStatus
		result2 error
	}
	GetVcsBackendStub        func(*models.Repository) (models.VcsBackend, error)
	getVcsBackendMutex       sync.RWMutex
	getVcsBackendArgsForCall []struct {
		arg1 *models.Repository
	}
	getVcsBackendReturns struct {
		result1 models.VcsBackend
		result2 error
	}
	getVcsBackendReturnsOnCall map[int]struct {
		result1 models.VcsBackend
		result2 error
	}
	SearchPullRequestStub        func(context.Context, *auth.Authenticator, *models.Repository, string) (*models.PullRequest, error)
	searchPullRequestMutex       sync.RWMutex
	searchPullRequestArgsForCall []struct {
		arg1 context.Context
		arg2 *auth.Authenticator
		arg3 *models.Repository
		arg4 string
	}
	searchPullRequestReturns struct {
		result1 *models.PullRequest
		result2 error
	}
	searchPullRequestReturnsOnCall map[int]struct {
		result1 *models.PullRequest
		result2 error
	}
	VerifyOptionsForFullOnboardStub        func(*auth.Authenticator, *options.Options) error
	verifyOptionsForFullOnboardMutex       sync.RWMutex
	verifyOptionsForFullOnboardArgsForCall []struct {
		arg1 *auth.Authenticator
		arg2 *options.Options
	}
	verifyOptionsForFullOnboardReturns struct {
		result1 error
	}
	verifyOptionsForFullOnboardReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeToolImplementation) CheckForks(arg1 *options.Options) error {
	fake.checkForksMutex.Lock()
	ret, specificReturn := fake.checkForksReturnsOnCall[len(fake.checkForksArgsForCall)]
	fake.checkForksArgsForCall = append(fake.checkForksArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.CheckForksStub
	fakeReturns := fake.checkForksReturns
	fake.recordInvocation("CheckForks", []interface{}{arg1})
	fake.checkForksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) CheckForksCallCount() int {
	fake.checkForksMutex.RLock()
	defer fake.checkForksMutex.RUnlock()
	return len(fake.checkForksArgsForCall)
}

func (fake *FakeToolImplementation) CheckForksCalls(stub func(*options.Options) error) {
	fake.checkForksMutex.Lock()
	defer fake.checkForksMutex.Unlock()
	fake.CheckForksStub = stub
}

func (fake *FakeToolImplementation) CheckForksArgsForCall(i int) *options.Options {
	fake.checkForksMutex.RLock()
	defer fake.checkForksMutex.RUnlock()
	argsForCall := fake.checkForksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) CheckForksReturns(result1 error) {
	fake.checkForksMutex.Lock()
	defer fake.checkForksMutex.Unlock()
	fake.CheckForksStub = nil
	fake.checkForksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CheckForksReturnsOnCall(i int, result1 error) {
	fake.checkForksMutex.Lock()
	defer fake.checkForksMutex.Unlock()
	fake.CheckForksStub = nil
	if fake.checkForksReturnsOnCall == nil {
		fake.checkForksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkForksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CheckPolicyFork(arg1 *options.Options) error {
	fake.checkPolicyForkMutex.Lock()
	ret, specificReturn := fake.checkPolicyForkReturnsOnCall[len(fake.checkPolicyForkArgsForCall)]
	fake.checkPolicyForkArgsForCall = append(fake.checkPolicyForkArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.CheckPolicyForkStub
	fakeReturns := fake.checkPolicyForkReturns
	fake.recordInvocation("CheckPolicyFork", []interface{}{arg1})
	fake.checkPolicyForkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) CheckPolicyForkCallCount() int {
	fake.checkPolicyForkMutex.RLock()
	defer fake.checkPolicyForkMutex.RUnlock()
	return len(fake.checkPolicyForkArgsForCall)
}

func (fake *FakeToolImplementation) CheckPolicyForkCalls(stub func(*options.Options) error) {
	fake.checkPolicyForkMutex.Lock()
	defer fake.checkPolicyForkMutex.Unlock()
	fake.CheckPolicyForkStub = stub
}

func (fake *FakeToolImplementation) CheckPolicyForkArgsForCall(i int) *options.Options {
	fake.checkPolicyForkMutex.RLock()
	defer fake.checkPolicyForkMutex.RUnlock()
	argsForCall := fake.checkPolicyForkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) CheckPolicyForkReturns(result1 error) {
	fake.checkPolicyForkMutex.Lock()
	defer fake.checkPolicyForkMutex.Unlock()
	fake.CheckPolicyForkStub = nil
	fake.checkPolicyForkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CheckPolicyForkReturnsOnCall(i int, result1 error) {
	fake.checkPolicyForkMutex.Lock()
	defer fake.checkPolicyForkMutex.Unlock()
	fake.CheckPolicyForkStub = nil
	if fake.checkPolicyForkReturnsOnCall == nil {
		fake.checkPolicyForkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkPolicyForkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) ConfigureControls(arg1 models.VcsBackend, arg2 *models.Repository, arg3 []*models.Branch, arg4 []models.ControlConfiguration) error {
	var arg3Copy []*models.Branch
	if arg3 != nil {
		arg3Copy = make([]*models.Branch, len(arg3))
		copy(arg3Copy, arg3)
	}
	var arg4Copy []models.ControlConfiguration
	if arg4 != nil {
		arg4Copy = make([]models.ControlConfiguration, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.configureControlsMutex.Lock()
	ret, specificReturn := fake.configureControlsReturnsOnCall[len(fake.configureControlsArgsForCall)]
	fake.configureControlsArgsForCall = append(fake.configureControlsArgsForCall, struct {
		arg1 models.VcsBackend
		arg2 *models.Repository
		arg3 []*models.Branch
		arg4 []models.ControlConfiguration
	}{arg1, arg2, arg3Copy, arg4Copy})
	stub := fake.ConfigureControlsStub
	fakeReturns := fake.configureControlsReturns
	fake.recordInvocation("ConfigureControls", []interface{}{arg1, arg2, arg3Copy, arg4Copy})
	fake.configureControlsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) ConfigureControlsCallCount() int {
	fake.configureControlsMutex.RLock()
	defer fake.configureControlsMutex.RUnlock()
	return len(fake.configureControlsArgsForCall)
}

func (fake *FakeToolImplementation) ConfigureControlsCalls(stub func(models.VcsBackend, *models.Repository, []*models.Branch, []models.ControlConfiguration) error) {
	fake.configureControlsMutex.Lock()
	defer fake.configureControlsMutex.Unlock()
	fake.ConfigureControlsStub = stub
}

func (fake *FakeToolImplementation) ConfigureControlsArgsForCall(i int) (models.VcsBackend, *models.Repository, []*models.Branch, []models.ControlConfiguration) {
	fake.configureControlsMutex.RLock()
	defer fake.configureControlsMutex.RUnlock()
	argsForCall := fake.configureControlsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeToolImplementation) ConfigureControlsReturns(result1 error) {
	fake.configureControlsMutex.Lock()
	defer fake.configureControlsMutex.Unlock()
	fake.ConfigureControlsStub = nil
	fake.configureControlsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) ConfigureControlsReturnsOnCall(i int, result1 error) {
	fake.configureControlsMutex.Lock()
	defer fake.configureControlsMutex.Unlock()
	fake.ConfigureControlsStub = nil
	if fake.configureControlsReturnsOnCall == nil {
		fake.configureControlsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.configureControlsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CreatePolicyPR(arg1 *auth.Authenticator, arg2 *options.Options, arg3 *models.Repository, arg4 *policy.RepoPolicy) (*models.PullRequest, error) {
	fake.createPolicyPRMutex.Lock()
	ret, specificReturn := fake.createPolicyPRReturnsOnCall[len(fake.createPolicyPRArgsForCall)]
	fake.createPolicyPRArgsForCall = append(fake.createPolicyPRArgsForCall, struct {
		arg1 *auth.Authenticator
		arg2 *options.Options
		arg3 *models.Repository
		arg4 *policy.RepoPolicy
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreatePolicyPRStub
	fakeReturns := fake.createPolicyPRReturns
	fake.recordInvocation("CreatePolicyPR", []interface{}{arg1, arg2, arg3, arg4})
	fake.createPolicyPRMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolImplementation) CreatePolicyPRCallCount() int {
	fake.createPolicyPRMutex.RLock()
	defer fake.createPolicyPRMutex.RUnlock()
	return len(fake.createPolicyPRArgsForCall)
}

func (fake *FakeToolImplementation) CreatePolicyPRCalls(stub func(*auth.Authenticator, *options.Options, *models.Repository, *policy.RepoPolicy) (*models.PullRequest, error)) {
	fake.createPolicyPRMutex.Lock()
	defer fake.createPolicyPRMutex.Unlock()
	fake.CreatePolicyPRStub = stub
}

func (fake *FakeToolImplementation) CreatePolicyPRArgsForCall(i int) (*auth.Authenticator, *options.Options, *models.Repository, *policy.RepoPolicy) {
	fake.createPolicyPRMutex.RLock()
	defer fake.createPolicyPRMutex.RUnlock()
	argsForCall := fake.createPolicyPRArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeToolImplementation) CreatePolicyPRReturns(result1 *models.PullRequest, result2 error) {
	fake.createPolicyPRMutex.Lock()
	defer fake.createPolicyPRMutex.Unlock()
	fake.CreatePolicyPRStub = nil
	fake.createPolicyPRReturns = struct {
		result1 *models.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) CreatePolicyPRReturnsOnCall(i int, result1 *models.PullRequest, result2 error) {
	fake.createPolicyPRMutex.Lock()
	defer fake.createPolicyPRMutex.Unlock()
	fake.CreatePolicyPRStub = nil
	if fake.createPolicyPRReturnsOnCall == nil {
		fake.createPolicyPRReturnsOnCall = make(map[int]struct {
			result1 *models.PullRequest
			result2 error
		})
	}
	fake.createPolicyPRReturnsOnCall[i] = struct {
		result1 *models.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) GetAttestationReader(arg1 *models.Repository) (models.AttestationStorageReader, error) {
	fake.getAttestationReaderMutex.Lock()
	ret, specificReturn := fake.getAttestationReaderReturnsOnCall[len(fake.getAttestationReaderArgsForCall)]
	fake.getAttestationReaderArgsForCall = append(fake.getAttestationReaderArgsForCall, struct {
		arg1 *models.Repository
	}{arg1})
	stub := fake.GetAttestationReaderStub
	fakeReturns := fake.getAttestationReaderReturns
	fake.recordInvocation("GetAttestationReader", []interface{}{arg1})
	fake.getAttestationReaderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolImplementation) GetAttestationReaderCallCount() int {
	fake.getAttestationReaderMutex.RLock()
	defer fake.getAttestationReaderMutex.RUnlock()
	return len(fake.getAttestationReaderArgsForCall)
}

func (fake *FakeToolImplementation) GetAttestationReaderCalls(stub func(*models.Repository) (models.AttestationStorageReader, error)) {
	fake.getAttestationReaderMutex.Lock()
	defer fake.getAttestationReaderMutex.Unlock()
	fake.GetAttestationReaderStub = stub
}

func (fake *FakeToolImplementation) GetAttestationReaderArgsForCall(i int) *models.Repository {
	fake.getAttestationReaderMutex.RLock()
	defer fake.getAttestationReaderMutex.RUnlock()
	argsForCall := fake.getAttestationReaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) GetAttestationReaderReturns(result1 models.AttestationStorageReader, result2 error) {
	fake.getAttestationReaderMutex.Lock()
	defer fake.getAttestationReaderMutex.Unlock()
	fake.GetAttestationReaderStub = nil
	fake.getAttestationReaderReturns = struct {
		result1 models.AttestationStorageReader
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) GetAttestationReaderReturnsOnCall(i int, result1 models.AttestationStorageReader, result2 error) {
	fake.getAttestationReaderMutex.Lock()
	defer fake.getAttestationReaderMutex.Unlock()
	fake.GetAttestationReaderStub = nil
	if fake.getAttestationReaderReturnsOnCall == nil {
		fake.getAttestationReaderReturnsOnCall = make(map[int]struct {
			result1 models.AttestationStorageReader
			result2 error
		})
	}
	fake.getAttestationReaderReturnsOnCall[i] = struct {
		result1 models.AttestationStorageReader
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) GetBranchControls(arg1 context.Context, arg2 models.VcsBackend, arg3 *models.Repository, arg4 *models.Branch) (*slsa.ControlSetStatus, error) {
	fake.getBranchControlsMutex.Lock()
	ret, specificReturn := fake.getBranchControlsReturnsOnCall[len(fake.getBranchControlsArgsForCall)]
	fake.getBranchControlsArgsForCall = append(fake.getBranchControlsArgsForCall, struct {
		arg1 context.Context
		arg2 models.VcsBackend
		arg3 *models.Repository
		arg4 *models.Branch
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetBranchControlsStub
	fakeReturns := fake.getBranchControlsReturns
	fake.recordInvocation("GetBranchControls", []interface{}{arg1, arg2, arg3, arg4})
	fake.getBranchControlsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolImplementation) GetBranchControlsCallCount() int {
	fake.getBranchControlsMutex.RLock()
	defer fake.getBranchControlsMutex.RUnlock()
	return len(fake.getBranchControlsArgsForCall)
}

func (fake *FakeToolImplementation) GetBranchControlsCalls(stub func(context.Context, models.VcsBackend, *models.Repository, *models.Branch) (*slsa.ControlSetStatus, error)) {
	fake.getBranchControlsMutex.Lock()
	defer fake.getBranchControlsMutex.Unlock()
	fake.GetBranchControlsStub = stub
}

func (fake *FakeToolImplementation) GetBranchControlsArgsForCall(i int) (context.Context, models.VcsBackend, *models.Repository, *models.Branch) {
	fake.getBranchControlsMutex.RLock()
	defer fake.getBranchControlsMutex.RUnlock()
	argsForCall := fake.getBranchControlsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeToolImplementation) GetBranchControlsReturns(result1 *slsa.ControlSetStatus, result2 error) {
	fake.getBranchControlsMutex.Lock()
	defer fake.getBranchControlsMutex.Unlock()
	fake.GetBranchControlsStub = nil
	fake.getBranchControlsReturns = struct {
		result1 *slsa.ControlSetStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) GetBranchControlsReturnsOnCall(i int, result1 *slsa.ControlSetStatus, result2 error) {
	fake.getBranchControlsMutex.Lock()
	defer fake.getBranchControlsMutex.Unlock()
	fake.GetBranchControlsStub = nil
	if fake.getBranchControlsReturnsOnCall == nil {
		fake.getBranchControlsReturnsOnCall = make(map[int]struct {
			result1 *slsa.ControlSetStatus
			result2 error
		})
	}
	fake.getBranchControlsReturnsOnCall[i] = struct {
		result1 *slsa.ControlSetStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) GetPolicyStatus(arg1 context.Context, arg2 *auth.Authenticator, arg3 *options.Options, arg4 *models.Repository) (*slsa.ControlStatus, error) {
	fake.getPolicyStatusMutex.Lock()
	ret, specificReturn := fake.getPolicyStatusReturnsOnCall[len(fake.getPolicyStatusArgsForCall)]
	fake.getPolicyStatusArgsForCall = append(fake.getPolicyStatusArgsForCall, struct {
		arg1 context.Context
		arg2 *auth.Authenticator
		arg3 *options.Options
		arg4 *models.Repository
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetPolicyStatusStub
	fakeReturns := fake.getPolicyStatusReturns
	fake.recordInvocation("GetPolicyStatus", []interface{}{arg1, arg2, arg3, arg4})
	fake.getPolicyStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolImplementation) GetPolicyStatusCallCount() int {
	fake.getPolicyStatusMutex.RLock()
	defer fake.getPolicyStatusMutex.RUnlock()
	return len(fake.getPolicyStatusArgsForCall)
}

func (fake *FakeToolImplementation) GetPolicyStatusCalls(stub func(context.Context, *auth.Authenticator, *options.Options, *models.Repository) (*slsa.ControlStatus, error)) {
	fake.getPolicyStatusMutex.Lock()
	defer fake.getPolicyStatusMutex.Unlock()
	fake.GetPolicyStatusStub = stub
}

func (fake *FakeToolImplementation) GetPolicyStatusArgsForCall(i int) (context.Context, *auth.Authenticator, *options.Options, *models.Repository) {
	fake.getPolicyStatusMutex.RLock()
	defer fake.getPolicyStatusMutex.RUnlock()
	argsForCall := fake.getPolicyStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeToolImplementation) GetPolicyStatusReturns(result1 *slsa.ControlStatus, result2 error) {
	fake.getPolicyStatusMutex.Lock()
	defer fake.getPolicyStatusMutex.Unlock()
	fake.GetPolicyStatusStub = nil
	fake.getPolicyStatusReturns = struct {
		result1 *slsa.ControlStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) GetPolicyStatusReturnsOnCall(i int, result1 *slsa.ControlStatus, result2 error) {
	fake.getPolicyStatusMutex.Lock()
	defer fake.getPolicyStatusMutex.Unlock()
	fake.GetPolicyStatusStub = nil
	if fake.getPolicyStatusReturnsOnCall == nil {
		fake.getPolicyStatusReturnsOnCall = make(map[int]struct {
			result1 *slsa.ControlStatus
			result2 error
		})
	}
	fake.getPolicyStatusReturnsOnCall[i] = struct {
		result1 *slsa.ControlStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) GetVcsBackend(arg1 *models.Repository) (models.VcsBackend, error) {
	fake.getVcsBackendMutex.Lock()
	ret, specificReturn := fake.getVcsBackendReturnsOnCall[len(fake.getVcsBackendArgsForCall)]
	fake.getVcsBackendArgsForCall = append(fake.getVcsBackendArgsForCall, struct {
		arg1 *models.Repository
	}{arg1})
	stub := fake.GetVcsBackendStub
	fakeReturns := fake.getVcsBackendReturns
	fake.recordInvocation("GetVcsBackend", []interface{}{arg1})
	fake.getVcsBackendMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolImplementation) GetVcsBackendCallCount() int {
	fake.getVcsBackendMutex.RLock()
	defer fake.getVcsBackendMutex.RUnlock()
	return len(fake.getVcsBackendArgsForCall)
}

func (fake *FakeToolImplementation) GetVcsBackendCalls(stub func(*models.Repository) (models.VcsBackend, error)) {
	fake.getVcsBackendMutex.Lock()
	defer fake.getVcsBackendMutex.Unlock()
	fake.GetVcsBackendStub = stub
}

func (fake *FakeToolImplementation) GetVcsBackendArgsForCall(i int) *models.Repository {
	fake.getVcsBackendMutex.RLock()
	defer fake.getVcsBackendMutex.RUnlock()
	argsForCall := fake.getVcsBackendArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) GetVcsBackendReturns(result1 models.VcsBackend, result2 error) {
	fake.getVcsBackendMutex.Lock()
	defer fake.getVcsBackendMutex.Unlock()
	fake.GetVcsBackendStub = nil
	fake.getVcsBackendReturns = struct {
		result1 models.VcsBackend
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) GetVcsBackendReturnsOnCall(i int, result1 models.VcsBackend, result2 error) {
	fake.getVcsBackendMutex.Lock()
	defer fake.getVcsBackendMutex.Unlock()
	fake.GetVcsBackendStub = nil
	if fake.getVcsBackendReturnsOnCall == nil {
		fake.getVcsBackendReturnsOnCall = make(map[int]struct {
			result1 models.VcsBackend
			result2 error
		})
	}
	fake.getVcsBackendReturnsOnCall[i] = struct {
		result1 models.VcsBackend
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) SearchPullRequest(arg1 context.Context, arg2 *auth.Authenticator, arg3 *models.Repository, arg4 string) (*models.PullRequest, error) {
	fake.searchPullRequestMutex.Lock()
	ret, specificReturn := fake.searchPullRequestReturnsOnCall[len(fake.searchPullRequestArgsForCall)]
	fake.searchPullRequestArgsForCall = append(fake.searchPullRequestArgsForCall, struct {
		arg1 context.Context
		arg2 *auth.Authenticator
		arg3 *models.Repository
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.SearchPullRequestStub
	fakeReturns := fake.searchPullRequestReturns
	fake.recordInvocation("SearchPullRequest", []interface{}{arg1, arg2, arg3, arg4})
	fake.searchPullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolImplementation) SearchPullRequestCallCount() int {
	fake.searchPullRequestMutex.RLock()
	defer fake.searchPullRequestMutex.RUnlock()
	return len(fake.searchPullRequestArgsForCall)
}

func (fake *FakeToolImplementation) SearchPullRequestCalls(stub func(context.Context, *auth.Authenticator, *models.Repository, string) (*models.PullRequest, error)) {
	fake.searchPullRequestMutex.Lock()
	defer fake.searchPullRequestMutex.Unlock()
	fake.SearchPullRequestStub = stub
}

func (fake *FakeToolImplementation) SearchPullRequestArgsForCall(i int) (context.Context, *auth.Authenticator, *models.Repository, string) {
	fake.searchPullRequestMutex.RLock()
	defer fake.searchPullRequestMutex.RUnlock()
	argsForCall := fake.searchPullRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeToolImplementation) SearchPullRequestReturns(result1 *models.PullRequest, result2 error) {
	fake.searchPullRequestMutex.Lock()
	defer fake.searchPullRequestMutex.Unlock()
	fake.SearchPullRequestStub = nil
	fake.searchPullRequestReturns = struct {
		result1 *models.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) SearchPullRequestReturnsOnCall(i int, result1 *models.PullRequest, result2 error) {
	fake.searchPullRequestMutex.Lock()
	defer fake.searchPullRequestMutex.Unlock()
	fake.SearchPullRequestStub = nil
	if fake.searchPullRequestReturnsOnCall == nil {
		fake.searchPullRequestReturnsOnCall = make(map[int]struct {
			result1 *models.PullRequest
			result2 error
		})
	}
	fake.searchPullRequestReturnsOnCall[i] = struct {
		result1 *models.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboard(arg1 *auth.Authenticator, arg2 *options.Options) error {
	fake.verifyOptionsForFullOnboardMutex.Lock()
	ret, specificReturn := fake.verifyOptionsForFullOnboardReturnsOnCall[len(fake.verifyOptionsForFullOnboardArgsForCall)]
	fake.verifyOptionsForFullOnboardArgsForCall = append(fake.verifyOptionsForFullOnboardArgsForCall, struct {
		arg1 *auth.Authenticator
		arg2 *options.Options
	}{arg1, arg2})
	stub := fake.VerifyOptionsForFullOnboardStub
	fakeReturns := fake.verifyOptionsForFullOnboardReturns
	fake.recordInvocation("VerifyOptionsForFullOnboard", []interface{}{arg1, arg2})
	fake.verifyOptionsForFullOnboardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboardCallCount() int {
	fake.verifyOptionsForFullOnboardMutex.RLock()
	defer fake.verifyOptionsForFullOnboardMutex.RUnlock()
	return len(fake.verifyOptionsForFullOnboardArgsForCall)
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboardCalls(stub func(*auth.Authenticator, *options.Options) error) {
	fake.verifyOptionsForFullOnboardMutex.Lock()
	defer fake.verifyOptionsForFullOnboardMutex.Unlock()
	fake.VerifyOptionsForFullOnboardStub = stub
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboardArgsForCall(i int) (*auth.Authenticator, *options.Options) {
	fake.verifyOptionsForFullOnboardMutex.RLock()
	defer fake.verifyOptionsForFullOnboardMutex.RUnlock()
	argsForCall := fake.verifyOptionsForFullOnboardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboardReturns(result1 error) {
	fake.verifyOptionsForFullOnboardMutex.Lock()
	defer fake.verifyOptionsForFullOnboardMutex.Unlock()
	fake.VerifyOptionsForFullOnboardStub = nil
	fake.verifyOptionsForFullOnboardReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboardReturnsOnCall(i int, result1 error) {
	fake.verifyOptionsForFullOnboardMutex.Lock()
	defer fake.verifyOptionsForFullOnboardMutex.Unlock()
	fake.VerifyOptionsForFullOnboardStub = nil
	if fake.verifyOptionsForFullOnboardReturnsOnCall == nil {
		fake.verifyOptionsForFullOnboardReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyOptionsForFullOnboardReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeToolImplementation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
